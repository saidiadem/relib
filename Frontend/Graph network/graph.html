<html>
  <head>
    <meta charset="utf-8" />

    <script>
      function neighbourhoodHighlight(params) {
        // console.log("in nieghbourhoodhighlight");
        allNodes = nodes.get({ returnType: "Object" });
        // originalNodes = JSON.parse(JSON.stringify(allNodes));
        // if something is selected:
        if (params.nodes.length > 0) {
          highlightActive = true;
          var i, j;
          var selectedNode = params.nodes[0];
          var degrees = 2;

          // mark all nodes as hard to read.
          for (let nodeId in allNodes) {
            // nodeColors[nodeId] = allNodes[nodeId].color;
            allNodes[nodeId].color = "rgba(200,200,200,0.5)";
            if (allNodes[nodeId].hiddenLabel === undefined) {
              allNodes[nodeId].hiddenLabel = allNodes[nodeId].label;
              allNodes[nodeId].label = undefined;
            }
          }
          var connectedNodes = network.getConnectedNodes(selectedNode);
          var allConnectedNodes = [];

          // get the second degree nodes
          for (i = 1; i < degrees; i++) {
            for (j = 0; j < connectedNodes.length; j++) {
              allConnectedNodes = allConnectedNodes.concat(
                network.getConnectedNodes(connectedNodes[j])
              );
            }
          }

          // all second degree nodes get a different color and their label back
          for (i = 0; i < allConnectedNodes.length; i++) {
            // allNodes[allConnectedNodes[i]].color = "pink";
            allNodes[allConnectedNodes[i]].color = "rgba(150,150,150,0.75)";
            if (allNodes[allConnectedNodes[i]].hiddenLabel !== undefined) {
              allNodes[allConnectedNodes[i]].label =
                allNodes[allConnectedNodes[i]].hiddenLabel;
              allNodes[allConnectedNodes[i]].hiddenLabel = undefined;
            }
          }

          // all first degree nodes get their own color and their label back
          for (i = 0; i < connectedNodes.length; i++) {
            // allNodes[connectedNodes[i]].color = undefined;
            allNodes[connectedNodes[i]].color = nodeColors[connectedNodes[i]];
            if (allNodes[connectedNodes[i]].hiddenLabel !== undefined) {
              allNodes[connectedNodes[i]].label =
                allNodes[connectedNodes[i]].hiddenLabel;
              allNodes[connectedNodes[i]].hiddenLabel = undefined;
            }
          }

          // the main node gets its own color and its label back.
          // allNodes[selectedNode].color = undefined;
          allNodes[selectedNode].color = nodeColors[selectedNode];
          if (allNodes[selectedNode].hiddenLabel !== undefined) {
            allNodes[selectedNode].label = allNodes[selectedNode].hiddenLabel;
            allNodes[selectedNode].hiddenLabel = undefined;
          }
        } else if (highlightActive === true) {
          // console.log("highlightActive was true");
          // reset all nodes
          for (let nodeId in allNodes) {
            // allNodes[nodeId].color = "purple";
            allNodes[nodeId].color = nodeColors[nodeId];
            // delete allNodes[nodeId].color;
            if (allNodes[nodeId].hiddenLabel !== undefined) {
              allNodes[nodeId].label = allNodes[nodeId].hiddenLabel;
              allNodes[nodeId].hiddenLabel = undefined;
            }
          }
          highlightActive = false;
        }

        // transform the object into an array
        var updateArray = [];
        if (params.nodes.length > 0) {
          for (let nodeId in allNodes) {
            if (allNodes.hasOwnProperty(nodeId)) {
              // console.log(allNodes[nodeId]);
              updateArray.push(allNodes[nodeId]);
            }
          }
          nodes.update(updateArray);
        } else {
          // console.log("Nothing was selected");
          for (let nodeId in allNodes) {
            if (allNodes.hasOwnProperty(nodeId)) {
              // console.log(allNodes[nodeId]);
              // allNodes[nodeId].color = {};
              updateArray.push(allNodes[nodeId]);
            }
          }
          nodes.update(updateArray);
        }
      }

      function filterHighlight(params) {
        allNodes = nodes.get({ returnType: "Object" });
        // if something is selected:
        if (params.nodes.length > 0) {
          filterActive = true;
          let selectedNodes = params.nodes;

          // hiding all nodes and saving the label
          for (let nodeId in allNodes) {
            allNodes[nodeId].hidden = true;
            if (allNodes[nodeId].savedLabel === undefined) {
              allNodes[nodeId].savedLabel = allNodes[nodeId].label;
              allNodes[nodeId].label = undefined;
            }
          }

          for (let i = 0; i < selectedNodes.length; i++) {
            allNodes[selectedNodes[i]].hidden = false;
            if (allNodes[selectedNodes[i]].savedLabel !== undefined) {
              allNodes[selectedNodes[i]].label =
                allNodes[selectedNodes[i]].savedLabel;
              allNodes[selectedNodes[i]].savedLabel = undefined;
            }
          }
        } else if (filterActive === true) {
          // reset all nodes
          for (let nodeId in allNodes) {
            allNodes[nodeId].hidden = false;
            if (allNodes[nodeId].savedLabel !== undefined) {
              allNodes[nodeId].label = allNodes[nodeId].savedLabel;
              allNodes[nodeId].savedLabel = undefined;
            }
          }
          filterActive = false;
        }

        // transform the object into an array
        var updateArray = [];
        if (params.nodes.length > 0) {
          for (let nodeId in allNodes) {
            if (allNodes.hasOwnProperty(nodeId)) {
              updateArray.push(allNodes[nodeId]);
            }
          }
          nodes.update(updateArray);
        } else {
          for (let nodeId in allNodes) {
            if (allNodes.hasOwnProperty(nodeId)) {
              updateArray.push(allNodes[nodeId]);
            }
          }
          nodes.update(updateArray);
        }
      }

      function selectNode(nodes) {
        network.selectNodes(nodes);
        neighbourhoodHighlight({ nodes: nodes });
        return nodes;
      }

      function selectNodes(nodes) {
        network.selectNodes(nodes);
        filterHighlight({ nodes: nodes });
        return nodes;
      }

      function highlightFilter(filter) {
        let selectedNodes = [];
        let selectedProp = filter["property"];
        if (filter["item"] === "node") {
          let allNodes = nodes.get({ returnType: "Object" });
          for (let nodeId in allNodes) {
            if (
              allNodes[nodeId][selectedProp] &&
              filter["value"].includes(
                allNodes[nodeId][selectedProp].toString()
              )
            ) {
              selectedNodes.push(nodeId);
            }
          }
        } else if (filter["item"] === "edge") {
          let allEdges = edges.get({ returnType: "object" });
          // check if the selected property exists for selected edge and select the nodes connected to the edge
          for (let edge in allEdges) {
            if (
              allEdges[edge][selectedProp] &&
              filter["value"].includes(allEdges[edge][selectedProp].toString())
            ) {
              selectedNodes.push(allEdges[edge]["from"]);
              selectedNodes.push(allEdges[edge]["to"]);
            }
          }
        }
        selectNodes(selectedNodes);
      }
    </script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/dist/vis-network.min.css"
      integrity="sha512-WgxfT5LWjfszlPHXRmBWHkV2eceiWTOBvrKCNbdgDYTHrT2AeLCGbF4sZlZw3UMN3WtL0tGUoIAKsu8mllg/XA=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/vis-network.min.js"
      integrity="sha512-LnvoEWDFrqGHlHmDD2101OrLcbsfkrzoSpvtSQtxK3RMnRV0eOkhhBN2dXHKRrUU8p2DGRTk35n4O8nWSVe1mQ=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>

    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6"
      crossorigin="anonymous"
    />
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-JEW9xMcG8R+pH31jmWH6WWP0WintQrMb4s7ZOdauHnUtxwoG2vI5DkLtS3qm9Ekf"
      crossorigin="anonymous"
    ></script>

    <style type="text/css">
      #mynetwork {
        width: 100%;
        height: 100vh;
        background-color: #ffffff;
        border: none;
        position: relative;
      }

      .legend {
        padding: 10px;
        background-color: white;
        border: 1px solid #ccc;
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 1000;
        border-radius: 5px;
      }
      .legend-item {
        display: flex;
        align-items: center;
        margin-bottom: 5px;
      }
      .legend-color {
        width: 20px;
        height: 20px;
        margin-right: 10px;
        border-radius: 50%;
        display: inline-block;
      }

      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
      }

      .header-controls {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 1000;
        display: flex;
        align-items: center;
        gap: 15px;
      }

      .logo-container {
        position: absolute;
        top: 20px;
        right: 20px;
        z-index: 1000;
      }

      .logo {
        width: 80px;
        height: 80px;
        object-fit: contain;
      }

      .back-button {
        background: linear-gradient(135deg, #0a1929 0%, #1a2332 100%);
        color: #F5E6D3;
        border: 2px solid #D4B896;
        padding: 10px 20px;
        border-radius: 8px;
        font-size: 0.95rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        text-decoration: none;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .back-button:hover {
        background: linear-gradient(135deg, #1a2332 0%, #2a3342 100%);
        border-color: #E5D2A2;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(212, 184, 150, 0.3);
      }
    </style>
  </head>

  <body>
    <div class="header-controls">
      <a href="search.html" class="back-button">
        ‚Üê Back to Search
      </a>
    </div>

    <div class="logo-container">
      <img src="../assets/image.png" alt="ReLib Logo" class="logo">
    </div>
    
    <div id="mynetwork"></div>

    <!-- Load API client -->
    <script src="api-client.js"></script>
    <!-- Load graph data and functionality -->
    <script src="graph-data.js"></script>
    <script type="text/javascript">
      document.addEventListener("DOMContentLoaded", function () {
        // Check for search parameter in URL
        const urlParams = new URLSearchParams(window.location.search);
        const searchQuery = urlParams.get('search');
        
        if (searchQuery) {
          console.log(`Search query: ${searchQuery}`);
          // You can implement search/filter logic here
          // For now, we'll just load the full graph
        }

        // This method is responsible for drawing the graph
        async function drawGraph() {
          var container = document.getElementById("mynetwork");

          // Load graph data from the external file
          var graphData = await loadGraphData();
          
          // Get the raw node and edge data
          var nodesArray = graphData.nodes.get();
          var edgesArray = graphData.edges.get();

          // Sort by drawOrder if present (fallback to original order)
          nodesArray.sort((a, b) => {
            const orderA = a.drawOrder !== undefined ? a.drawOrder : 999;
            const orderB = b.drawOrder !== undefined ? b.drawOrder : 999;
            return orderA - orderB;
          });
          
          edgesArray.sort((a, b) => {
            const orderA = a.drawOrder !== undefined ? a.drawOrder : 0;
            const orderB = b.drawOrder !== undefined ? b.drawOrder : 0;
            return orderA - orderB;
          });

          console.log(`Preparing to add ${nodesArray.length} nodes and ${edgesArray.length} edges dynamically (sorted by drawOrder)`);

          // Create empty DataSets
          nodes = new vis.DataSet([]);
          edges = new vis.DataSet([]);

          // Define network options
          var options = {
            configure: {
              enabled: false,
            },
            nodes: {
              shape: 'box',
              font: { 
                size: 12, 
                color: '#ffffff' 
              },
              color: {
                border: '#0a1929',
                background: '#0a1929',
                highlight: {
                  border: '#0a1929',
                  background: '#1a2332'
                }
              }
            },
            edges: {
              color: {
                color: "#0a1929",
                opacity: 1.0,
              },
              smooth: {
                enabled: true,
                type: "dynamic",
              },
              scaling: {
                min: 1,
                max: 2,
              },
            },
            interaction: {
              dragNodes: true,
              hideEdgesOnDrag: false,
              hideNodesOnDrag: false,
              hover: true,
            },
            physics: {
              forceAtlas2Based: {
                avoidOverlap: 0,
                centralGravity: 0.015,
                damping: 0.4,
                gravitationalConstant: -50,
                springConstant: 0.08,
                springLength: 100,
              },
              solver: "forceAtlas2Based",
              stabilization: {
                enabled: true,
                fit: true,
                iterations: 1000,
                onlyDynamicEdges: false,
                updateInterval: 50,
              },
            },
          };

          // Create network with empty data
          data = { nodes: nodes, edges: edges };
          network = new vis.Network(container, data, options);

          // Set up event listeners
          network.on("selectNode", neighbourhoodHighlight);

          // Add nodes and edges dynamically one by one
          await addNodesAndEdgesDynamically(nodesArray, edgesArray);

          return network;
        }

        // Add nodes and edges one by one with animation
        async function addNodesAndEdgesDynamically(nodesArray, edgesArray) {
          const nodeDelay = 400; // Delay between adding each node with its edges

          console.log("Starting dynamic node and edge addition...");

          // Create a map of edges by source node for quick lookup
          const edgesByNode = {};
          edgesArray.forEach(edge => {
            if (!edgesByNode[edge.from]) {
              edgesByNode[edge.from] = [];
            }
            edgesByNode[edge.from].push(edge);
          });

          // Add nodes one by one, ensuring all edges from previous nodes are added first
          for (let i = 0; i < nodesArray.length; i++) {
            const node = nodesArray[i];
            console.log(`Adding node ${i + 1}/${nodesArray.length}: ${node.label}`);
            
            // Add the node
            nodes.add(node);
            
            // Now check all previous nodes and add any edges that point to this new node
            for (let j = 0; j < i; j++) {
              const prevNode = nodesArray[j];
              const prevNodeEdges = edgesByNode[prevNode.id] || [];
              
              for (const edge of prevNodeEdges) {
                // Add edge if it points to the newly added node and hasn't been added yet
                if (edge.to === node.id && !edges.get(edge.id)) {
                  console.log(`  Adding edge from ${prevNode.label} to ${node.label}`);
                  edges.add(edge);
                }
              }
            }
            
            // Wait before adding next node
            await new Promise(resolve => setTimeout(resolve, nodeDelay));
          }

          // Add any remaining edges (in case some were skipped because target didn't exist yet)
          console.log("Adding any remaining edges...");
          const existingEdgeIds = new Set(edges.getIds());
          const remainingEdges = edgesArray.filter(edge => !existingEdgeIds.has(edge.id));
          
          for (const edge of remainingEdges) {
            if (nodes.get(edge.from) && nodes.get(edge.to)) {
              console.log(`  Adding remaining edge: ${edge.from} -> ${edge.to}`);
              edges.add(edge);
            }
          }

          console.log("All nodes and edges added dynamically!");

          // Store references to all edges
          allEdges = edges.get({ returnType: "Object" });
        }

        // Draw the graph
        drawGraph().catch(error => {
          console.error("Failed to draw graph:", error);
          alert("Failed to load graph. Check console for details.");
        });
      });
    </script>
  </body>
</html>
